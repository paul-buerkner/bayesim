library(bayesim)
library(extraDistr)
library(brms)
library(testthat)

# Unit tests for custom gompertz

# Just a small function, to get the alpha shape-argument, for reference gompertz functions
get_b <- function(mu, eta) {
  b <- (1 / mu) * log((-1 / eta) * log(1 / 2) + 1)
  return(b)
}
get_a <- function(mu, eta) {
  # a of extraDistr
  a <- get_b(mu, eta) * eta
  return(a)
}

n <- 10000   # number of testvalues
eps <- 1e-6
x <- exp(seq(from = eps , to = 200 , length.out = n)) # testset, exp(200) comes close to Max-Double
unit <- seq(from = eps, to = 1 - eps, length.out = n)

n_small <- 10
mus <- seq(from = eps, to = 10, length.out = n_small)
etas <- seq(from = eps, to = 10, length.out = n_small)

test_that("custom-gompertz", {
  # calculate gompertz
  dgompertz_results <- bayesim::dgompertz(x, mu = 1, eta = 0.1)
  qgompertz_results <- bayesim::qgompertz(unit, mu = 1, eta = 0.1)
  # check length
  expect_equal(n, length(dgompertz_results))
  expect_equal(n, length(qgompertz_results))
  # check values against comparable implementation
  expect_eps(dgompertz_results, extraDistr::dgompertz(x, get_a(1, 0.1), get_b(1, 0.1)), eps)
  expect_eps(qgompertz_results, extraDistr::qgompertz(unit, get_a(1, 0.1), get_b(1, 0.1)), eps)
  # also check other shape parameters
  expect_eps(bayesim::dgompertz(x, mu = 1, eta = 4), extraDistr::dgompertz(x, get_a(1, 4), get_b(1, 4)), eps)
  expect_eps(bayesim::qgompertz(unit, mu = 1, eta = 4), extraDistr::qgompertz(unit, get_a(1, 4), get_b(1, 4)), eps)

  # check the RNG
  mu <- 1
  accepted_median_eps <- 0.1
  gompertz_samples <- bayesim::rgompertz(n, mu, 3)
  expect_equal(n, length(gompertz_samples))
  expect_eps(median(gompertz_samples), mu, accepted_median_eps) # this test should work most of the time, but might fail sometimes
  n_failed_medians <- 0
  p_acceptable_failures <- 0.2 # with arbitrary median_eps of 0.1, about 8-20% of medians will be outside that range
  n_acceptable_failures <- ceiling(length(mus) * length(etas) * p_acceptable_failures)


  # check many shape parameters
  for(m in mus) {
    for(eta in etas) {
      expect_eps(bayesim::dgompertz(x, mu = m, eta = eta), extraDistr::dgompertz(x, get_a(m, eta), get_b(m, eta)), eps)
      expect_eps(bayesim::qgompertz(unit, mu = m, eta = eta), extraDistr::qgompertz(unit, get_a(m, eta), get_b(m, eta)), eps)

      median_distance <- abs(median(bayesim::rgompertz(n, mu = m, eta = eta)) - m)
      if(median_distance > accepted_median_eps) {
        n_failed_medians <- n_failed_medians + 1
      }
    }
  }
  expect_bigger(n_acceptable_failures, n_failed_medians)
  # this test might still fail. This is to be expected, given it is generated by RNG

  # now check density function for some errors
  expect_error(bayesim::dgompertz(1, 2)) # to few arguments
  expect_error(bayesim::dgompertz(1, 2, 3, 4, 5)) # to many arguments
  expect_error(bayesim::dgompertz(-1, mu = 2, eta = 2)) # x is not allowed to be smaller 0
  expect_error(bayesim::dgompertz(1, mu = 0, eta = 2))  # mu is not allowed to be 0 or smaller
  expect_error(bayesim::dgompertz(1, mu = 1, eta = 0))  # eta is not allowed to be 0 or smaller
  expect_error(bayesim::dgompertz(1, mu = 0, eta = 2))  # mu is not allowed to be 0 or smaller
  expect_error(bayesim::dgompertz(1, mu = 1, eta = 0))  # eta is not allowed to be 1 or smaller

  # do same for quantile function
  expect_error(bayesim::qgompertz(1, 2)) # to few arguments
  expect_error(bayesim::qgompertz(1, 2, 3, 4, 5)) # to many arguments
  expect_error(bayesim::qgompertz(-1, mu = 2, eta = 2)) # x is not allowed to be smaller 0
  expect_error(bayesim::qgompertz(1, mu = 0, eta = 2))  # mu is not allowed to be 0 or smaller
  expect_error(bayesim::qgompertz(1, mu = 1, eta = 0))  # eta is not allowed to be 0 or smaller
  expect_error(bayesim::qgompertz(c(-1, 2), mu = 2, eta = 2))  # q is not allowed to be outside [0, 1]
  expect_error(bayesim::qgompertz(1, mu = 0, eta = 2))  # mu is not allowed to be 0 or smaller
  expect_error(bayesim::qgompertz(1, mu = 1, eta = 0))  # eta is not allowed to be 1 or smaller

})
